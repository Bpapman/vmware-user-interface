/*
 * 
 * 
 */
package jung1;


import edu.uci.ics.jung.algorithms.layout.BalloonLayout;
import edu.uci.ics.jung.algorithms.layout.TreeLayout;
import edu.uci.ics.jung.graph.DelegateForest;
import edu.uci.ics.jung.graph.DelegateTree;
import edu.uci.ics.jung.graph.DirectedGraph;
import edu.uci.ics.jung.graph.DirectedSparseMultigraph;
import edu.uci.ics.jung.graph.Forest;
import edu.uci.ics.jung.graph.Tree;
import edu.uci.ics.jung.visualization.GraphZoomScrollPane;
import edu.uci.ics.jung.visualization.Layer;
import edu.uci.ics.jung.visualization.VisualizationServer;
import edu.uci.ics.jung.visualization.VisualizationViewer;
import edu.uci.ics.jung.visualization.control.CrossoverScalingControl;
import edu.uci.ics.jung.visualization.control.DefaultModalGraphMouse;
import edu.uci.ics.jung.visualization.control.ModalGraphMouse;
import edu.uci.ics.jung.visualization.control.ModalLensGraphMouse;
import edu.uci.ics.jung.visualization.control.ScalingControl;
import edu.uci.ics.jung.visualization.decorators.EdgeShape;
import edu.uci.ics.jung.visualization.decorators.ToStringLabeller;
import edu.uci.ics.jung.visualization.layout.LayoutTransition;
import edu.uci.ics.jung.visualization.transform.LensSupport;
import edu.uci.ics.jung.visualization.transform.MutableTransformer;
import edu.uci.ics.jung.visualization.transform.MutableTransformerDecorator;
import edu.uci.ics.jung.visualization.transform.shape.HyperbolicShapeTransformer;
import edu.uci.ics.jung.visualization.transform.shape.ViewLensSupport;
import edu.uci.ics.jung.visualization.util.Animator;
import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Container;
import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.GridLayout;
import java.awt.Shape;
import java.awt.Toolkit;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.ItemEvent;
import java.awt.event.ItemListener;
import java.awt.geom.AffineTransform;
import java.awt.geom.Ellipse2D;
import java.awt.geom.Point2D;
import java.util.Map;
import javax.swing.BorderFactory;
import javax.swing.JApplet;
import javax.swing.JButton;
import javax.swing.JComboBox;
import javax.swing.JPanel;
import javax.swing.JTextArea;
import javax.swing.JToggleButton;
import org.apache.commons.collections15.Factory;
import org.apache.commons.collections15.functors.ConstantTransformer;

/**
 *
 * @author Brett
 */
public class GraphCreate extends JApplet{
    //temporary testing strings
        String ID = "A0";
        String MAC = "192.168.1.1";

        
  Forest<String,Integer> graph;

  Factory<DirectedGraph<String,Integer>> graphFactory = 
    new Factory<DirectedGraph<String,Integer>>() {

        @Override
    public DirectedGraph<String, Integer> create() {
      return new DirectedSparseMultigraph<>();
    }
  };

  Factory<Tree<String,Integer>> treeFactory =
    new Factory<Tree<String,Integer>> () {

        @Override
    public Tree<String, Integer> create() {
      return new DelegateTree<>(graphFactory);
    }};
        

  Factory<Integer> edgeFactory = new Factory<Integer>() {
    int i=0;
      @Override
    public Integer create() {
      return i++;
    }};
   
  Factory<String> vertexFactory = new Factory<String>() {
    int i=0;
      @Override
    public String create() {
      return "V"+i++;
    }};

    /**
     * the visual component and renderer for the graph
     */
    VisualizationViewer<String,Integer> vv;
    
    VisualizationServer.Paintable rings;
    
    String root;
    
    TreeLayout<String,Integer> layout;
    
    BalloonLayout<String,Integer> radialLayout;
    /**
     * provides a Hyperbolic lens for the view
     */
    LensSupport hyperbolicViewSupport;
//    private String vertex;
    
    
    
    public GraphCreate(Map<String, NodeData> NodeTable, Map<String, EdgeData> EdgeTable) {
        
        // create a simple graph for the demo
        graph = new DelegateForest<>();

        createTree(NodeTable, EdgeTable);
        
        layout = new TreeLayout<>(graph);
        radialLayout = new BalloonLayout<>(graph);
        radialLayout.setSize(new Dimension(800,800));
        Dimension screenSize = Toolkit.getDefaultToolkit().getScreenSize();
 
        vv =  new VisualizationViewer<>(layout, new Dimension(screenSize.width - 50,screenSize.height - 200));
        vv.setBackground(Color.white);
        vv.getRenderContext().setEdgeShapeTransformer(new EdgeShape.Line());
        vv.getRenderContext().setVertexLabelTransformer(new ToStringLabeller());
        // add a listener for ToolTips
        vv.setVertexToolTipTransformer(new ToStringLabeller());
        vv.getRenderContext().setArrowFillPaintTransformer(new ConstantTransformer(Color.lightGray));
        rings = new GraphCreate.Rings(radialLayout);
        
        Container content = getContentPane();
        final GraphZoomScrollPane panel = new GraphZoomScrollPane(vv);
        content.add(panel);
       
        
        final DefaultModalGraphMouse graphMouse = new DefaultModalGraphMouse();
//editing - final DefaultModalGraphMouse graphMouse = new DefaultModalGraphMouse(vv.getRenderContext(), vertexFactory, edgeFactory);

        vv.setGraphMouse(graphMouse);
        vv.addKeyListener(graphMouse.getModeKeyListener());
        
        hyperbolicViewSupport = 
            new ViewLensSupport<>(vv, new HyperbolicShapeTransformer(vv, 
                vv.getRenderContext().getMultiLayerTransformer().getTransformer(Layer.VIEW)), 
                    new ModalLensGraphMouse());


        graphMouse.addItemListener(hyperbolicViewSupport.getGraphMouse().getModeListener());

        JComboBox modeBox = graphMouse.getModeComboBox();
        //annotation doesn't work well when flipping graph modes
//        modeBox.removeItemAt(3);
//        modeBox.removeItemAt
        //end annotation removal
        modeBox.addItemListener(graphMouse.getModeListener());
        graphMouse.setMode(ModalGraphMouse.Mode.TRANSFORMING);

        final ScalingControl scaler = new CrossoverScalingControl();
        
        vv.scaleToLayout(scaler);

        JButton plus = new JButton("+");
        plus.addActionListener(new ActionListener() {
            @Override
            public void actionPerformed(ActionEvent e) {
                scaler.scale(vv, 1.1f, vv.getCenter());
            }
        });
        JButton minus = new JButton("-");
        minus.addActionListener(new ActionListener() {
            @Override
            public void actionPerformed(ActionEvent e) {
                scaler.scale(vv, 1/1.1f, vv.getCenter());
            }
        });
        
        JToggleButton radial = new JToggleButton("Balloon");
        radial.addItemListener(new ItemListener() {

            @Override
      public void itemStateChanged(ItemEvent e) {
        if(e.getStateChange() == ItemEvent.SELECTED) {

          LayoutTransition<String,Integer> lt =
            new LayoutTransition<>(vv, layout, radialLayout);
          Animator animator = new Animator(lt);
          animator.start();
          vv.getRenderContext().getMultiLayerTransformer().getTransformer(Layer.LAYOUT).setToIdentity();
          vv.addPreRenderPaintable(rings);
        } else {

          LayoutTransition<String,Integer> lt =
            new LayoutTransition<>(vv, radialLayout, layout);
          Animator animator = new Animator(lt);
          animator.start();
          vv.getRenderContext().getMultiLayerTransformer().getTransformer(Layer.LAYOUT).setToIdentity();
          vv.removePreRenderPaintable(rings);
        }
        vv.repaint();
      }});
        /*
        final JRadioButton hyperView = new JRadioButton("Hyperbolic View");
        hyperView.addItemListener(new ItemListener(){
            public void itemStateChanged(ItemEvent e) {
                hyperbolicViewSupport.activate(e.getStateChange() == ItemEvent.SELECTED);
            }
        });
        */

        JPanel scaleGrid = new JPanel(new GridLayout(1,0));
        scaleGrid.setBorder(BorderFactory.createTitledBorder("Zoom"));

        JPanel controls = new JPanel();
        scaleGrid.add(plus);
        scaleGrid.add(minus);
        controls.add(radial);
        controls.add(scaleGrid);
        controls.add(modeBox);

        JTextArea tf = new JTextArea(); 
        tf.setColumns(22);
        tf.setRows(4);
        tf.setEditable(false);
        controls.add(tf);
       
//      Testing stuff          
        tf.setText("Type:  Switch \n");
        tf.append("ID:  " + ID + " \n");
        tf.append("IP/MAC address:  " + MAC + " \n");
        tf.append("Enabled: True");
       
        //controls.add(hyperView);
        content.add(controls, BorderLayout.SOUTH);
    }
        
    
        
    class Rings implements VisualizationServer.Paintable {
      
      BalloonLayout<String,Integer> layout;
      
      public Rings(BalloonLayout<String,Integer> layout) {
        this.layout = layout;
      }
        @Override
    public void paint(Graphics g) {
      g.setColor(Color.gray);
    
      Graphics2D g2d = (Graphics2D)g;

      Ellipse2D ellipse = new Ellipse2D.Double();
      for(String v : layout.getGraph().getVertices()) {
        Double radius = layout.getRadii().get(v);
        if(radius == null) {
              continue;
        }
        Point2D p = layout.transform(v);
        ellipse.setFrame(-radius, -radius, 2*radius, 2*radius);
        AffineTransform at = AffineTransform.getTranslateInstance(p.getX(), p.getY());
        Shape shape = at.createTransformedShape(ellipse);
        
        MutableTransformer viewTransformer =
          vv.getRenderContext().getMultiLayerTransformer().getTransformer(Layer.VIEW);
        
        if(viewTransformer instanceof MutableTransformerDecorator) {
          shape = vv.getRenderContext().getMultiLayerTransformer().transform(shape);
        } else {
          shape = vv.getRenderContext().getMultiLayerTransformer().transform(Layer.LAYOUT,shape);
        }

        g2d.draw(shape);
      }
    }

        @Override
    public boolean useTransform() {
      return true;
    }
    }      
    
        private void createTree(Map<String, NodeData> NodeTable, Map<String, EdgeData> EdgeTable) {
        //mandatory server main vertex    
        graph.addVertex("proton");
/*      
 * 
 *  Makes all the vertex's then all the edges. 
 */
        String HashID = "node";
        String EdgeID = "edge";
        Integer count = 1;
        String newNode;
        
        //testing string
//        System.out.println(HashID + count);
        System.out.println(NodeTable.toString());
        System.out.println(EdgeTable.toString());
        
        while(NodeTable.get("node" + count) != null) {            
            newNode = NodeTable.get(HashID + count).getName();
            System.out.println(newNode + " has been drawn");
            count++;
            graph.addVertex(newNode);
        }
        count = 1;

        //more testing woulnd't draw edges
//        graph.addEdge(edgeFactory.create(), "proton", "node1");
//        graph.addEdge(edgeFactory.create(), "proton", "node2");
//        graph.addEdge(edgeFactory.create(), "proton", "node3");
        while(EdgeTable.get("edge" + count) != null){
            System.out.println(EdgeTable.get(EdgeID + count).getParent() + " is connected to " + EdgeTable.get(EdgeID + count).getChild());
            graph.addEdge(edgeFactory.create(), EdgeTable.get(EdgeID + count).getParent(), EdgeTable.get(EdgeID + count).getChild());
            count++;
        }


/*
//      graph.addEdge(edgeFactory.create(), "Edge "+id, "A0", "B0")
        graph.addVertex("A0");
        graph.addVertex("A1");
        graph.addVertex("A2");
        graph.addVertex("A3");

        
        graph.addEdge(edgeFactory.create(), "Proton", "A0");
        graph.addEdge(edgeFactory.create(), "Proton", "A1");
        graph.addEdge(edgeFactory.create(), "Proton", "A2");
        graph.addEdge(edgeFactory.create(), "Proton", "A3");
        graph.addEdge(edgeFactory.create(), "server", "A4");
*/        
   }       
        
}
