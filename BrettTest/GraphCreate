/*
 * 
 * 
 */
package jung1;


import edu.uci.ics.jung.algorithms.layout.BalloonLayout;
import edu.uci.ics.jung.algorithms.layout.TreeLayout;
import edu.uci.ics.jung.algorithms.layout.util.Relaxer;
import edu.uci.ics.jung.graph.DelegateForest;
import edu.uci.ics.jung.graph.DelegateTree;
import edu.uci.ics.jung.graph.DirectedGraph;
import edu.uci.ics.jung.graph.DirectedSparseMultigraph;
import edu.uci.ics.jung.graph.Forest;
import edu.uci.ics.jung.graph.Tree;
import edu.uci.ics.jung.visualization.GraphZoomScrollPane;
import edu.uci.ics.jung.visualization.Layer;
import edu.uci.ics.jung.visualization.VisualizationServer;
import edu.uci.ics.jung.visualization.VisualizationViewer;
import edu.uci.ics.jung.visualization.control.CrossoverScalingControl;
import edu.uci.ics.jung.visualization.control.DefaultModalGraphMouse;
import edu.uci.ics.jung.visualization.control.ModalGraphMouse;
import edu.uci.ics.jung.visualization.control.ScalingControl;
import edu.uci.ics.jung.visualization.decorators.EdgeShape;
import edu.uci.ics.jung.visualization.decorators.ToStringLabeller;
import edu.uci.ics.jung.visualization.layout.LayoutTransition;
import edu.uci.ics.jung.visualization.picking.PickedState;
import edu.uci.ics.jung.visualization.transform.MutableTransformer;
import edu.uci.ics.jung.visualization.transform.MutableTransformerDecorator;
import edu.uci.ics.jung.visualization.util.Animator;
import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Container;
import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.GridLayout;
import java.awt.Shape;
import java.awt.Toolkit;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.ItemEvent;
import java.awt.event.ItemListener;
import java.awt.geom.AffineTransform;
import java.awt.geom.Ellipse2D;
import java.awt.geom.Point2D;
import java.awt.image.BufferedImage;
import java.io.*;
import java.util.Map;
import javax.imageio.ImageIO;
import javax.swing.*;
import org.apache.commons.collections15.Factory;
import org.apache.commons.collections15.functors.ConstantTransformer;

/**
 *
 * @author Brett
 */
public class GraphCreate extends JApplet{

  //Default factories and graph settings for delegate tree layout
  Forest<String,Integer> graph;

  Factory<DirectedGraph<String,Integer>> graphFactory = 
    new Factory<DirectedGraph<String,Integer>>() {

        @Override
    public DirectedGraph<String, Integer> create() {
      return new DirectedSparseMultigraph<>();
    }
  };

  Factory<Tree<String,Integer>> treeFactory =
    new Factory<Tree<String,Integer>> () {

        @Override
    public Tree<String, Integer> create() {
      return new DelegateTree<>(graphFactory);
    }};
        

  Factory<Integer> edgeFactory = new Factory<Integer>() {
    int i=0;
      @Override
    public Integer create() {
      return i++;
    }};
   
  Factory<String> vertexFactory = new Factory<String>() {
    int i=0;
      @Override
    public String create() {
      return "V"+i++;
    }};

    /**
     * Visual component and renderer for the graph
     */
    VisualizationViewer<String,Integer> vv;
    
    VisualizationServer.Paintable rings;
    
    String root;
    
    TreeLayout<String,Integer> layout;
    
    BalloonLayout<String,Integer> radialLayout;
    
    public GraphCreate(final Map<String, NodeData> NodeTable, final Map<String, EdgeData> EdgeTable) {
        
        //Creates the graph (format above)
        graph = new DelegateForest<>();
        createTree(NodeTable, EdgeTable);
        
        
        //Initializations + Dimensions
        layout = new TreeLayout<>(graph);
        radialLayout = new BalloonLayout<>(graph);
        radialLayout.setSize(new Dimension(2000,2000));
        Dimension screenSize = Toolkit.getDefaultToolkit().getScreenSize(); 
        vv =  new VisualizationViewer<>(layout, new Dimension(screenSize.width - 40,screenSize.height - 175));
        
        //Labeler
        vv.setBackground(Color.white);
        vv.getRenderContext().setEdgeShapeTransformer(new EdgeShape.Line());
        vv.getRenderContext().setVertexLabelTransformer(new ToStringLabeller());
        // add a listener for ToolTips
        vv.setVertexToolTipTransformer(new ToStringLabeller());
        vv.getRenderContext().setArrowFillPaintTransformer(new ConstantTransformer(Color.lightGray));
        rings = new GraphCreate.Rings(radialLayout);
        
        //Adds zoomable pane
        Container content = getContentPane();
        final GraphZoomScrollPane panel = new GraphZoomScrollPane(vv);
        content.add(panel);
       
        //Mouse plugins
        final DefaultModalGraphMouse graphMouse = new DefaultModalGraphMouse();
        vv.setGraphMouse(graphMouse);
        vv.addKeyListener(graphMouse.getModeKeyListener());
        
        //Mode of mouse, defaults transforming
        JComboBox modeBox = graphMouse.getModeComboBox();
        modeBox.addItemListener(graphMouse.getModeListener());
        graphMouse.setMode(ModalGraphMouse.Mode.TRANSFORMING);

        //Adds scaling functionality
        final ScalingControl scaler = new CrossoverScalingControl();        
        vv.scaleToLayout(scaler);
        
        //Zoom in scales by 10%
        JButton plus = new JButton("+");
        plus.addActionListener(new ActionListener() {
            @Override
            public void actionPerformed(ActionEvent e) {
                scaler.scale(vv, 1.1f, vv.getCenter());
            }
        });
        
        //Zoom out scales by 10%
        JButton minus = new JButton("-");
        minus.addActionListener(new ActionListener() {
            @Override
            public void actionPerformed(ActionEvent e) {
                scaler.scale(vv, 1/1.1f, vv.getCenter());
            }
        });
        
        //View saver (Grabs the window not the total graph)
        JButton imgSave = new JButton("Save Image");
        imgSave.addActionListener(new ActionListener() {
            @Override
            public void actionPerformed(ActionEvent e) {
                //img dimensions
                int width = vv.getWidth();
                int height = vv.getHeight();
                
                //File dialog
                JFrame saveFrame = new JFrame();
                JFileChooser fileImg = new JFileChooser(".");
                int saveChoice = fileImg.showSaveDialog(saveFrame);
                File selectedFile;
                
                //If save then get selected file name
                if (saveChoice == JFileChooser.APPROVE_OPTION)
                {
                    selectedFile = fileImg.getSelectedFile();
                }
                //If null won't write a file
                else 
                {
                    selectedFile = null;
                }
               
                //Create img
                BufferedImage bi = new BufferedImage(width, height, BufferedImage.TYPE_INT_RGB);
                Graphics2D graphics = bi.createGraphics();
                vv.paint(graphics);
                graphics.dispose();
                
                //Write img at the location
                try
                {
                    ImageIO.write(bi, "jpg", selectedFile);                    
                }
                catch(Exception ee)
                {
                    JFrame notification = new JFrame();
                    JOptionPane.showMessageDialog(notification,"Error writing/creating image");
                }
                vv.setDoubleBuffered(true);
            }
        });
        
        //Zoom/camera reset
        JButton resetGrid = new JButton("Reset View");
        resetGrid.addActionListener(new ActionListener() {
            @Override
            public void actionPerformed(ActionEvent e) {
                //reset zoom               
                vv.getRenderContext().getMultiLayerTransformer().getTransformer(Layer.LAYOUT).setToIdentity();
                vv.getRenderContext().getMultiLayerTransformer().getTransformer(Layer.VIEW).setToIdentity();
                
                //reset Camera (beta) using relaxer algorithm
                /*
                //TreeLayout<String, Integer> Treelayout = vv.getGraphLayout();
                layout.initialize();
                Relaxer relaxer = vv.getModel().getRelaxer();
                if(relaxer != null) 
                {
                    relaxer.stop();
                    relaxer.prerelax();
                    relaxer.relax();
                } 
                */
            }
        });
        
        //Balloon toggle button
        JToggleButton radial = new JToggleButton("Balloon");
        radial.addItemListener(new ItemListener() {
            @Override
      public void itemStateChanged(ItemEvent e) {
        if(e.getStateChange() == ItemEvent.SELECTED) 
        {
          //Balloon layout
          LayoutTransition<String,Integer> lt =
            new LayoutTransition<>(vv, layout, radialLayout);
          Animator animator = new Animator(lt);
          animator.start();
          vv.getRenderContext().getMultiLayerTransformer().getTransformer(Layer.LAYOUT).setToIdentity();
          vv.addPreRenderPaintable(rings);
        } 
        else 
        {
          //Tree layout
          LayoutTransition<String,Integer> lt =
            new LayoutTransition<>(vv, radialLayout, layout);
          Animator animator = new Animator(lt);
          animator.start();
          vv.getRenderContext().getMultiLayerTransformer().getTransformer(Layer.LAYOUT).setToIdentity();
          vv.removePreRenderPaintable(rings);
        }
        vv.repaint();
      }});

        //all the button/tools on bottom pannel
        JPanel scaleGrid = new JPanel(new GridLayout(1,0));
        scaleGrid.setBorder(BorderFactory.createTitledBorder("Zoom"));

        JPanel controls = new JPanel();
        scaleGrid.add(plus);
        scaleGrid.add(minus);
        controls.add(radial);
        controls.add(resetGrid);
        controls.add(scaleGrid);
        controls.add(modeBox);
                       
        //Currently where the data for vertex's are displayed
        final JTextArea tf = new JTextArea();
        tf.setColumns(24);
        tf.setRows(3);
        tf.setEditable(false);
        
        controls.add(tf);
        controls.add(imgSave);
        
        //Data retrieval on click
        final PickedState<String> pickedState = vv.getPickedVertexState();
        pickedState.addItemListener(new ItemListener() 
        {
            @Override
            public void itemStateChanged(ItemEvent e) 
            {
                //retrieves vertex on 'picked' event
                Object subject = e.getItem();
                if (subject instanceof String) 
                {
                    String vertex = (String) subject;
                    String edges;
                    if (pickedState.isPicked(vertex)) 
                    {
                        //system check for errors
                        System.out.println("Vertex " + vertex + " is now selected");
                        
                        //iterates table to find matching name
                        for(Integer i = 1; NodeTable.get("node" + i) != null;)
                        {
                            
                            if(NodeTable.get("node" + i).getName().compareTo(vertex) == 0)
                            {
                            System.out.println("Found Match: " + NodeTable.get("node" + i).getName() + "  compared to:  " + vertex);                                
                            vertex = "node" + i;
                            edges = "edge" + i;
                            }
                            i++;
                        }
                        
                        //Edits JTextField for drawn info
                        tf.setText("Node name: " + NodeTable.get(vertex).getName() + "\n");
                        tf.append(NodeTable.get(vertex).getF1() + "\n");
                        tf.append(NodeTable.get(vertex).getF2() + "\n");
                        tf.append(NodeTable.get(vertex).getF3() + "\n");
//                        tf.append(EdgeTable.get(edges).getParent() + "\n");
                    } 
                    else 
                    {
                        System.out.println("Vertex " + vertex + " no longer selected");
                    }
                }
            }    
        });
        

       

       
        content.add(controls, BorderLayout.SOUTH);
    }
        
    
    //Baloon layout format (from sample code)    
    class Rings implements VisualizationServer.Paintable {
      
      BalloonLayout<String,Integer> layout;
      
    public Rings(BalloonLayout<String,Integer> layout) {
        this.layout = layout;
      }
        @Override
    public void paint(Graphics g) {
      g.setColor(Color.gray);
    
      Graphics2D g2d = (Graphics2D)g;

      Ellipse2D ellipse = new Ellipse2D.Double();
      for(String v : layout.getGraph().getVertices()) {
        Double radius = layout.getRadii().get(v);
        if(radius == null) {
              continue;
        }
        Point2D p = layout.transform(v);
        ellipse.setFrame(-radius, -radius, 2*radius, 2*radius);
        AffineTransform at = AffineTransform.getTranslateInstance(p.getX(), p.getY());
        Shape shape = at.createTransformedShape(ellipse);
        
        MutableTransformer viewTransformer =
          vv.getRenderContext().getMultiLayerTransformer().getTransformer(Layer.VIEW);
        
        if(viewTransformer instanceof MutableTransformerDecorator) {
          shape = vv.getRenderContext().getMultiLayerTransformer().transform(shape);
        } else {
          shape = vv.getRenderContext().getMultiLayerTransformer().transform(Layer.LAYOUT,shape);
        }

        g2d.draw(shape);
      }
    }
 
                
        @Override
    public boolean useTransform() {
      return true;
    }
    }      
 
        
        private void createTree(Map<String, NodeData> NodeTable, Map<String, EdgeData> EdgeTable) {
/*      
 *  Tree creation
 *  Makes all the vertex's then all the edges
 * Draws from HashMaps
 */
        //count variable and retrieved nodename (not mandatory string)   
        Integer count = 1;
        String newNode;
        
        //stops on a null key, graphs the nodenames
        while(NodeTable.get("node" + count) != null) {            
            newNode = NodeTable.get("node" + count).getName();
            System.out.println(newNode + " has been drawn");
            count++;
            graph.addVertex(newNode);
        }
        //reset count
        count = 1;

        //more testing woulnd't draw edges
//        graph.addEdge(edgeFactory.create(), "proton", "node1");
        //stops on null key, adds edges
        while(EdgeTable.get("edge" + count) != null){
            System.out.println(EdgeTable.get("edge" + count).getParent() + " is connected to " + EdgeTable.get("edge" + count).getChild());
            graph.addEdge(edgeFactory.create(), EdgeTable.get("edge" + count).getParent(), EdgeTable.get("edge" + count).getChild());
            count++;
        }


/*
        graph.addVertex("A0");
        graph.addEdge(edgeFactory.create(), "server", "A4");
*/        
   }       
        
}
